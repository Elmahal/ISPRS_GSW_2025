// Defining the classes

 /**
 * Function to mask clouds using the Sentinel-2 QA band
 * @param {ee.Image} image Sentinel-2 image
 * @return {ee.Image} cloud masked Sentinel-2 image
 */
function maskS2clouds(image) {
  var qa = image.select('QA60');

  // Bits 10 and 11 are clouds and cirrus, respectively.
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;

  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
              .and(qa.bitwiseAnd(cirrusBitMask).eq(0));

  return image.updateMask(mask).divide(10000);
}

// Define the geometry of Dubai in UAE
var uaeGeometry = ee.Geometry.Polygon([[
  [54.56009080550555, 25.347223899708194],
  [54.56009080550555, 24.637751158179807],
  [56.09268357894305, 24.637751158179807],
  [56.09268357894305, 25.347223899708194],
]]);

// Map the function over a month of data and take the median.
// Load Sentinel-2 TOA reflectance data (adjusted for processing changes
// that occurred after 2022-01-25).
var dataset = ee.ImageCollection('COPERNICUS/S2_HARMONIZED')
  .filterDate('2022-01-01', '2024-10-31')
  // Pre-filter to get less cloudy granules.
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))
  .filterBounds(uaeGeometry) // Filter the collection to UAE only
  .map(maskS2clouds);

var rgbVis = {
  min: 0.0,
  max: 0.3,
  bands: ['B4', 'B3', 'B2'],
};
 
Map.setCenter(53.9772, 24.4764, 12);  // Center the map on UAE (approximately)
Map.addLayer(dataset.median(), rgbVis, 'Cloud-Masked RGB');
// Define the export task parameters
var exportTask = Export.image.toDrive({
  image: dataset.median(), // Use the median image for export
  description: 'CloudMasked_UAE_DUBAI_Jan2022', // Set a descriptive name
  scale: 10, // Export at 10 meters resolution
  region: uaeGeometry, // Export the area within the UAE geometry
  fileFormat: 'GeoTIFF' // Specify the format as GeoTIFF
});

var label = 'Class';
var bands = ['B2', 'B3', 'B4', 'B8', 'B11', 'B12']; // Choose bands relevant to your classification

 // Merge all FeatureCollections into one for training
var trainingPoints = water_bodies.merge(sandy_areas).merge(mountains).merge(built_up);
    // Load Sentinel-2 imagery for the same region and time span as your training data
var sentinel2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
  .filterDate('2022-01-01', '2024-10-31')
  .filterBounds(trainingPoints.geometry())
  .filter(ee.Filter.lte('CLOUDY_PIXEL_PERCENTAGE', 20))
  .median();
  // Select bands relevant for classification
var bands = ['B2', 'B3', 'B4', 'B8', 'B11', 'B12'];
var input = sentinel2.select(bands);
// Sample the input imagery to create a FeatureCollection of training data
var training = input.sampleRegions({
  collection: trainingPoints,
  properties: ['Class'],
  scale: 10
});
/////// 
// Optionally, set the map's view to the training data's extent
Map.centerObject(trainingPoints, 10);
// Example: Hypothetical allPoints FeatureCollection
var allPoints = water_bodies.merge(built_up).merge(sandy_areas).merge(vegetation).merge(mountains);

// Randomly split the points into training and validation sets
var withRandom = allPoints.randomColumn('random');

var trainingPoints = withRandom.filter(ee.Filter.lt('random', 0.7));
var validationPoints = withRandom.filter(ee.Filter.gte('random', 0.7));

// Assuming 'input' is your classified image and 'classifier' is already trained
// Classify the validation dataset
var validation = input.sampleRegions({
  collection: validationPoints,
  properties: ['Class'],
  scale: 10
});
//var validated = validation.classify(classifier); 





 
